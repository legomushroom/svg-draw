// Generated by CoffeeScript 1.6.3
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define('line', ['ProtoClass', 'helpers', 'hammer'], function(ProtoClass, helpers, hammer) {
    var Line, _ref;
    return Line = (function(_super) {
      __extends(Line, _super);

      function Line() {
        _ref = Line.__super__.constructor.apply(this, arguments);
        return _ref;
      }

      Line.prototype.initialize = function(o) {
        var path;
        this.o = o != null ? o : {};
        this.set('id', helpers.genHash());
        path = this.o.path;
        this.set('path', this.o.path);
        this.set('points', path.get('points'));
        this.addContainer();
        this.serialize();
        return this;
      };

      Line.prototype.addContainer = function() {
        this.g = App.SVG.createElement('g', {
          id: this.get('id')
        });
        return this.events();
      };

      Line.prototype.events = function() {
        var _this = this;
        hammer($(this.g)).on('touch', function(e) {
          _this.currentDragHandle = e.target;
          return _this.preventEvent(e);
        });
        hammer($(this.g)).on('drag', function(e) {
          _this.dragHandle(e);
          return _this.preventEvent(e);
        });
        return hammer($(this.g)).on('release', function(e) {
          _this.currentDragHandle = null;
          return _this.preventEvent(e);
        });
      };

      Line.prototype.dragHandle = function(e) {
        var $segment, coords, data, points;
        $segment = $(this.currentDragHandle);
        data = $segment.data();
        coords = App.grid.getNearestCellCenter(App.helpers.getEventCoords(e));
        points = this.get('points');
        if (data.direction === 'x') {
          points[data.segment].y = coords.y;
          points[data.segment + 1].y = coords.y;
        } else {
          points[data.segment].x = coords.x;
          points[data.segment + 1].x = coords.x;
        }
        return this.serialize();
      };

      Line.prototype.preventEvent = function(e) {
        e.stopPropagation();
        e.preventDefault();
        return false;
      };

      Line.prototype.addDomElement = function() {
        var attr;
        attr = {
          stroke: '#00DFFC',
          'stroke-width': 2,
          fill: 'none',
          'marker-mid': 'url(#marker-mid)'
        };
        this.line = App.SVG.createElement('path', attr);
        this.g.appendChild(this.line);
        !this.appended && App.SVG.lineToDom(this.g);
        return this.appended = true;
      };

      Line.prototype.serialize = function() {
        var i, point, points, str, xRadius, xShift, yRadius, yShift, _i, _len;
        this.removeFromDom();
        this.addDomElement();
        str = '';
        points = this.get('points');
        for (i = _i = 0, _len = points.length; _i < _len; i = ++_i) {
          point = points[i];
          if (i === 0) {
            str += "M" + point.x + "," + point.y + " ";
          } else {
            if (point.curve == null) {
              str += "L" + point.x + "," + point.y + " ";
            } else {
              xShift = yShift = xRadius = yRadius = 0;
              if (point.curve === 'vertical') {
                yShift = App.gs / 2;
                yRadius = App.gs;
                yShift = this.path.yPolar === 'minus' ? yShift - App.gs : yShift;
              } else if (point.curve === 'horizontal') {
                xShift = App.gs / 2;
                xRadius = App.gs;
                xShift = this.path.xPolar === 'minus' ? xShift - App.gs : xShift;
              }
              xRadius = this.path.xPolar === 'minus' ? -xRadius : xRadius;
              yRadius = this.path.yPolar === 'minus' ? -yRadius : yRadius;
              str += "L " + (point.x - xShift) + ", " + (point.y - yShift) + " ";
              str += "a1,1 0 0,1 " + xRadius + "," + yRadius + " ";
            }
          }
        }
        App.SVG.setAttribute.call(this.line, 'd', str);
        this.addHandles(points);
        return this;
      };

      Line.prototype.addHandles = function(points) {
        var i, isY, nextPoint, point, _i, _len;
        if (points == null) {
          points = this.get('points');
        }
        this.handles = [];
        for (i = _i = 0, _len = points.length; _i < _len; i = ++_i) {
          point = points[i];
          if ((i >= points.length - 2) || (i === 0)) {
            continue;
          }
          nextPoint = points[i + 1];
          isY = point.x === nextPoint.x ? true : false;
          this.handles.push({
            x: isY ? point.x : (point.x + nextPoint.x) / 2,
            y: isY ? (point.y + nextPoint.y) / 2 : point.y,
            segment: i,
            direction: isY ? 'y' : 'x'
          });
        }
        return this.appendHandles();
      };

      Line.prototype.appendHandles = function() {
        var attr, handle, handleSvg, i, _i, _len, _ref1, _results;
        _ref1 = this.handles;
        _results = [];
        for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
          handle = _ref1[i];
          attr = {
            fill: 'red',
            'marker-mid': 'url(#marker-mid)',
            x: handle.x - (App.gs / 2),
            y: handle.y - (App.gs / 2),
            width: App.gs,
            height: App.gs,
            "class": 'path-handle',
            id: 'js-path-handle',
            'data-segment': handle.segment,
            'data-direction': handle.direction
          };
          handleSvg = App.SVG.createElement('rect', attr);
          _results.push(this.g.appendChild(handleSvg));
        }
        return _results;
      };

      Line.prototype.resetPoints = function(points) {
        this.set('points', points);
        this.serialize();
        return this;
      };

      Line.prototype.remove = function() {
        this.removeFromDom();
        return this;
      };

      Line.prototype.removeFromDom = function() {
        var _results;
        if (!this.g) {
          return;
        }
        _results = [];
        while (this.g.hasChildNodes()) {
          _results.push(this.g.removeChild(this.g.lastChild));
        }
        return _results;
      };

      return Line;

    })(ProtoClass);
  });

}).call(this);
