// Generated by CoffeeScript 1.6.2
(function() {
  define('path', ['two', 'jquery', 'helpers'], function(Two, $, helpers) {
    var Path;

    Path = (function() {
      function Path(o) {
        var vert, _i, _len, _ref,
          _this = this;

        this.o = o != null ? o : {};
        this.line = App.two.makeLine(this.o.coords.x, this.o.coords.y, this.o.coords.x, this.o.coords.y);
        this.line.noFill().stroke = this.o.strokeColor || "#00DFFC";
        this.line.linewidth = this.o.strokeWidth || 2;
        App.grid.holdCell(this.o.coords);
        _ref = this.line.vertices;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          vert = _ref[_i];
          vert.addSelf(this.line.translation);
        }
        this.line.translation.clear();
        setTimeout((function() {
          _this.$dom = $("#two-" + _this.line.id);
          return _this.addMarkers();
        }), 25);
      }

      Path.prototype.removeIfEmpty = function() {
        if (this.line.vertices.length > 2) {
          return;
        }
        App.grid.releaseCell({
          x: this.line.vertices[0].x,
          y: this.line.vertices[0].y
        });
        return this.line.remove();
      };

      Path.prototype.addPoint = function(coords) {
        var twojsCoords;

        coords = App.grid.getNearestCellCenter(coords);
        twojsCoords = helpers.makePoint(coords.x, coords.y);
        App.settings.isSmartPath && this.fillGapOnAdd(coords);
        return this.pushPoint(twojsCoords);
      };

      Path.prototype.fillGapOnAdd = function(coords) {
        var path, xGap, yGap;

        xGap = Math.abs(this.line.vertices[this.line.vertices.length - 1].x - coords.x) > App.gs;
        yGap = Math.abs(this.line.vertices[this.line.vertices.length - 1].y - coords.y) > App.gs;
        if (xGap || yGap) {
          path = App.grid.getGapPolyfill({
            from: {
              x: this.line.vertices[this.line.vertices.length - 1].x,
              y: this.line.vertices[this.line.vertices.length - 1].y
            },
            to: {
              x: coords.x,
              y: coords.y
            }
          });
          return this.addPathToLine(path);
        }
      };

      Path.prototype.addPathToLine = function(path) {
        var coord, i, xy, _i, _len, _results;

        _results = [];
        for (i = _i = 0, _len = path.length; _i < _len; i = ++_i) {
          coord = path[i];
          if (i === 0 || i === path.length - 1) {
            continue;
          }
          xy = App.grid.fromIJ({
            i: coord[0],
            j: coord[1]
          });
          _results.push(this.pushPoint(helpers.makePoint(xy.x, xy.y)));
        }
        return _results;
      };

      Path.prototype.pushPoint = function(point) {
        App.grid.holdCell(point);
        return this.line.vertices.push(point);
      };

      Path.prototype.coordsToTwo = function(x, y) {
        var v;

        if (arguments.length <= 1) {
          y = x.y;
          x = x.x;
        }
        v = new Two.Vector(x, y);
        v.position = new Two.Vector().copy(v);
        return v;
      };

      Path.prototype.addMarkers = function() {
        return this.$dom.attr('marker-mid', "url('#marker-mid')");
      };

      return Path;

    })();
    return Path;
  });

}).call(this);
