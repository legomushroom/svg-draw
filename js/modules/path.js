// Generated by CoffeeScript 1.6.2
(function() {
  define('path', ['two', 'jquery', 'helpers'], function(Two, $, helpers) {
    var Path;

    Path = (function() {
      Path.prototype.alwaysRecalc = true;

      function Path(o) {
        this.o = o != null ? o : {};
        this.id = helpers.genHash();
        this.type = 'path';
        this.isHoldCell = false;
        if (this.o.coords) {
          this.addLine(this.o.coords);
        }
      }

      Path.prototype.addLine = function(coords, normalize) {
        var vert, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4,
          _this = this;

        this.ij = App.grid.toIJ(coords);
        if (normalize) {
          if (((_ref = App.grid.atIJ({
            i: ij.i - 1,
            j: ij.j
          }).holder) != null ? _ref.id : void 0) === this.connectedTo.id) {
            coords.x -= App.gs / 2;
          }
          if (((_ref1 = App.grid.atIJ({
            i: ij.i + 1,
            j: ij.j
          }).holder) != null ? _ref1.id : void 0) === this.connectedTo.id) {
            coords.x += App.gs / 2;
          }
          if (((_ref2 = App.grid.atIJ({
            i: ij.i,
            j: ij.j - 1
          }).holder) != null ? _ref2.id : void 0) === this.connectedTo.id) {
            coords.y -= App.gs / 2;
          }
          if (((_ref3 = App.grid.atIJ({
            i: ij.i,
            j: ij.j + 1
          }).holder) != null ? _ref3.id : void 0) === this.connectedTo.id) {
            coords.y += App.gs / 2;
          }
        }
        this.line = App.two.makeLine(coords.x, coords.y, coords.x, coords.y);
        this.line.noFill().stroke = this.o.strokeColor || "#00DFFC";
        this.line.linewidth = this.o.strokeWidth || 2;
        App.grid.holdCell(coords, this);
        _ref4 = this.line.vertices;
        for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
          vert = _ref4[_i];
          vert.addSelf(this.line.translation);
        }
        this.line.translation.clear();
        return setTimeout((function() {
          _this.$dom = $("#two-" + _this.line.id);
          return _this.addMarkers();
        }), 25);
      };

      Path.prototype.removeIfEmpty = function() {
        if (!this.isEmpty()) {
          return;
        }
        App.grid.releaseCell({
          x: this.line.vertices[0].x,
          y: this.line.vertices[0].y
        }, this);
        return this.line.remove();
      };

      Path.prototype.isEmpty = function() {
        return this.line.vertices.length <= 2;
      };

      Path.prototype.addPoint = function(coords) {
        var twojsCoords;

        coords = App.grid.getNearestCellCenter(coords);
        if (!this.line) {
          return this.addLine(coords, true);
        } else {
          if (!this.alwaysRecalc) {
            twojsCoords = helpers.makePoint(coords.x, coords.y);
            App.settings.isSmartPath && this.fillGapOnAdd(coords);
            return this.pushPoint(twojsCoords);
          } else {
            return this.newEndPoint(coords);
          }
        }
      };

      Path.prototype.newEndPoint = function(coords) {
        var path;

        this.endIJ = App.grid.toIJ(coords);
        path = App.grid.getGapPolyfill({
          from: this.ij,
          to: this.endIJ
        });
        return this.resetLine(path);
      };

      Path.prototype.resetLine = function(path) {
        var i, point, vert, xy, _i, _j, _len, _len1, _ref, _ref1, _results,
          _this = this;

        if ((_ref = this.line) != null) {
          _ref.remove();
        }
        this.line = App.two.makeLine(path[0][0] * App.gs, path[0][1] * App.gs, path[0][0] * App.gs, path[0][1] * App.gs);
        this.line.noFill().stroke = this.o.strokeColor || "#00DFFC";
        this.line.linewidth = this.o.strokeWidth || 2;
        _ref1 = this.line.vertices;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          vert = _ref1[_i];
          vert.addSelf(this.line.translation);
        }
        this.line.translation.clear();
        setTimeout((function() {
          _this.$dom = $("#two-" + _this.line.id);
          return _this.addMarkers();
        }), 25);
        _results = [];
        for (i = _j = 0, _len1 = path.length; _j < _len1; i = ++_j) {
          point = path[i];
          if (i === 0) {
            continue;
          }
          xy = App.grid.fromIJ({
            i: point[0],
            j: point[1]
          });
          _results.push(this.line.vertices.push(helpers.makePoint(xy.x, xy.y)));
        }
        return _results;
      };

      Path.prototype.fillGapOnAdd = function(coords) {
        var path, xGap, yGap;

        xGap = Math.abs(this.line.vertices[this.line.vertices.length - 1].x - coords.x) > App.gs;
        yGap = Math.abs(this.line.vertices[this.line.vertices.length - 1].y - coords.y) > App.gs;
        if (xGap || yGap) {
          path = App.grid.getGapPolyfill({
            from: {
              x: this.line.vertices[this.line.vertices.length - 1].x,
              y: this.line.vertices[this.line.vertices.length - 1].y
            },
            to: {
              x: coords.x,
              y: coords.y
            }
          });
          return this.addPathToLine(path);
        }
      };

      Path.prototype.addPathToLine = function(path) {
        var coord, i, xy, _i, _len, _results;

        _results = [];
        for (i = _i = 0, _len = path.length; _i < _len; i = ++_i) {
          coord = path[i];
          if (i === 0 || i === path.length - 1) {
            continue;
          }
          xy = App.grid.fromIJ({
            i: coord[0],
            j: coord[1]
          });
          _results.push(this.pushPoint(helpers.makePoint(xy.x, xy.y)));
        }
        return _results;
      };

      Path.prototype.pushPoint = function(point) {
        App.grid.holdCell(point, this);
        return this.line.vertices.push(point);
      };

      Path.prototype.coordsToTwo = function(x, y) {
        var v;

        if (arguments.length <= 1) {
          y = x.y;
          x = x.x;
        }
        v = new Two.Vector(x, y);
        v.position = new Two.Vector().copy(v);
        return v;
      };

      Path.prototype.addMarkers = function() {
        return this.$dom.attr('marker-mid', "url('#marker-mid')");
      };

      return Path;

    })();
    return Path;
  });

}).call(this);
