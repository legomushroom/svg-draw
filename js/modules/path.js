// Generated by CoffeeScript 1.6.2
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  define('path', ['jquery', 'helpers', 'ProtoClass', 'line'], function($, helpers, ProtoClass, Line) {
    var Path;

    Path = (function(_super) {
      __extends(Path, _super);

      Path.prototype.type = 'path';

      Path.prototype.isHoldCell = false;

      function Path(o) {
        this.o = o != null ? o : {};
        this.id = helpers.genHash();
        if (this.o.coords) {
          this.set({
            startIJ: App.grid.toIJ(this.o.coords),
            endIJ: App.grid.toIJ(this.o.coords)
          });
        }
      }

      Path.prototype.onChange = function() {
        this.oldIntersects = helpers.cloneObj(this.intersects);
        return this.render();
      };

      Path.prototype.render = function(isRepaintIntersects) {
        if (isRepaintIntersects == null) {
          isRepaintIntersects = false;
        }
        this.removeFromGrid();
        this.recalcPath();
        this.makeLine();
        return App.grid.refreshGrid();
      };

      Path.prototype.recalcPath = function() {
        var i, ij, node, path, point, xy, _i, _len, _ref;

        path = App.grid.getGapPolyfill({
          from: this.startIJ,
          to: this.endIJ
        });
        this.points = [];
        for (i = _i = 0, _len = path.length; _i < _len; i = ++_i) {
          point = path[i];
          ij = {
            i: point[0],
            j: point[1]
          };
          xy = App.grid.fromIJ(ij);
          node = App.grid.atIJ(ij);
          if ((_ref = node.holders) == null) {
            node.holders = {};
          }
          node.holders[this.id] = this;
          point = {
            x: xy.x,
            y: xy.y,
            curve: null,
            i: i
          };
          this.points.push(point);
        }
        this.calcPolar();
        return this;
      };

      Path.prototype.calcPolar = function() {
        var firstPoint, lastPoint;

        firstPoint = this.points[0];
        lastPoint = this.points[this.points.length - 1];
        this.xPolar = firstPoint.x < lastPoint.x ? 'plus' : 'minus';
        return this.yPolar = firstPoint.y < lastPoint.y ? 'plus' : 'minus';
      };

      Path.prototype.repaintIntersects = function(intersects) {
        var name, path;

        for (name in intersects) {
          path = intersects[name];
          if (path.id === this.id) {
            continue;
          }
          path.render([path.id]);
        }
        return this.oldIntersects = {};
      };

      Path.prototype.detectCollisions = function() {
        var holder, myDirection, name, node, point, _i, _len, _ref, _results,
          _this = this;

        this.intersects = {};
        _ref = this.points;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          point = _ref[_i];
          myDirection = this.directionAt(point);
          node = App.grid.at(point);
          if (_.size(node.holders) > 1) {
            _.chain(node.holders).where({
              type: 'path'
            }).each(function(holder) {
              return _this.intersects[holder.id] = holder;
            });
            _results.push((function() {
              var _ref1, _results1;

              _ref1 = this.intersects;
              _results1 = [];
              for (name in _ref1) {
                holder = _ref1[name];
                if (holder.id === this.id) {
                  continue;
                }
                if (myDirection !== holder.directionAt(point) && holder.directionAt(point) !== 'corner' && myDirection !== 'corner') {
                  _results1.push(point.curve = "" + myDirection);
                } else {
                  _results1.push(void 0);
                }
              }
              return _results1;
            }).call(this));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      };

      Path.prototype.directionAt = function(xy) {
        var direction, point, _ref, _ref1, _ref2, _ref3;

        point = _.where(this.points, {
          x: xy.x,
          y: xy.y
        })[0];
        if (!point) {
          return 'corner';
        }
        if (((_ref = this.points[point.i - 1]) != null ? _ref.x : void 0) === point.x && ((_ref1 = this.points[point.i + 1]) != null ? _ref1.x : void 0) === point.x) {
          direction = 'vertical';
        } else if (((_ref2 = this.points[point.i - 1]) != null ? _ref2.y : void 0) === point.y && ((_ref3 = this.points[point.i + 1]) != null ? _ref3.y : void 0) === point.y) {
          direction = 'horizontal';
        } else {
          direction = 'corner';
        }
        return direction;
      };

      Path.prototype.makeLine = function() {
        if (this.line == null) {
          return this.line = new Line({
            path: this
          });
        } else {
          return this.line.resetPoints(this.points);
        }
      };

      Path.prototype.removeFromGrid = function() {
        var node, point, _i, _len, _ref, _results;

        if (this.points == null) {
          return;
        }
        _ref = this.points;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          point = _ref[_i];
          node = App.grid.at(point);
          _results.push(delete node.holders[this.id]);
        }
        return _results;
      };

      Path.prototype.removeIfEmpty = function() {
        if (this.isEmpty()) {
          this.line.remove();
          this.removeFromGrid();
        }
        return App.grid.refreshGrid();
      };

      Path.prototype.isEmpty = function() {
        return this.line.points.length <= 2;
      };

      return Path;

    })(ProtoClass);
    return Path;
  });

}).call(this);
